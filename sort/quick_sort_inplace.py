def quick_sort(arr, low=None, high=None):
    """
    Реализация сортировки Хоара (быстрой сортировки).
    
    Параметры:
        arr (list): Массив для сортировки.
        low (int, optional): Начальный индекс подмассива. По умолчанию 0.
        high (int, optional): Конечный индекс подмассива. По умолчанию len(arr)-1.
        
    Возвращает:
        list: Отсортированный массив.
    """
    # Инициализация границ при первом вызове функции
    if low is None:
        low = 0
    if high is None:
        high = len(arr) - 1
        
    # Рекурсивная сортировка, пока есть что сортировать
    if low < high:
        # Получаем индекс опорного элемента после разделения
        pivot_index = partition(arr, low, high)
        
        # Рекурсивно сортируем элементы до и после опорного
        quick_sort(arr, low, pivot_index - 1)
        quick_sort(arr, pivot_index + 1, high)
    
    return arr  # Возвращаем отсортированный массив


def partition(arr, low, high):
    """
    Вспомогательная функция для разделения массива.
    
    Выбирает опорный элемент и размещает все элементы меньше опорного
    слева от него, а все элементы больше - справа.
    
    Параметры:
        arr (list): Массив для разделения.
        low (int): Начальный индекс подмассива.
        high (int): Конечный индекс подмассива.
        
    Возвращает:
        int: Индекс опорного элемента после разделения.
    """
    # Выбираем последний элемент как опорный
    pivot = arr[high]
    
    # Указатель на позицию, где будет размещен опорный элемент
    i = low - 1
    
    # Проходим по всем элементам подмассива
    for j in range(low, high):
        # Если текущий элемент меньше или равен опорному
        if arr[j] <= pivot:
            # Увеличиваем указатель и меняем элементы местами
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    # Помещаем опорный элемент на правильную позицию
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    
    return i + 1  # Индекс опорного элемента
