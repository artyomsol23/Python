def heapify(arr, n, i):
    """
    Преобразует поддерево с корнем в индексе `i` в двоичную кучу (max-heap).
    
    :param arr: Массив, представляющий кучу
    :param n: Размер кучи (количество элементов)
    :param i: Индекс корня поддерева
    """
    largest = i  # Инициализируем наибольший элемент как текущий корень
    left = 2 * i + 1  # Индекс левого потомка
    right = 2 * i + 2  # Индекс правого потомка

    # Если левый потомок существует и больше текущего наибольшего элемента
    if left < n and arr[left] > arr[largest]:
        largest = left

    # Если правый потомок существует и больше текущего наибольшего элемента
    if right < n and arr[right] > arr[largest]:
        largest = right

    # Если наибольший элемент не корень
    if largest != i:
        # Меняем корень и наибольший элемент местами
        arr[i], arr[largest] = arr[largest], arr[i]
        # Рекурсивно преобразуем затронутое поддерево
        heapify(arr, n, largest)

def heap_sort(arr):
    """
    Сортирует массив с использованием алгоритма пирамидальной сортировки (Heap Sort).
    
    :param arr: Исходный массив для сортировки
    :return: Отсортированный массив (если нужна копия)
    """
    arr = arr.copy()  # Создаем копию, чтобы не менять исходный массив
    n = len(arr)

    # Построение max-heap
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # Последовательно извлекаем элементы из кучи
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)
    
    return arr  # Возвращаем отсортированную копию
